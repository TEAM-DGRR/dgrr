### 프로세스

1. 클라이언트1이 서버에 소켓 통신을 요청한다.
    1. 헤더에 유저 식별자(DB에 저장되는 번호, 통신용 식별자와는 별개)를 담아 보낸다.
    2. 메시지 listener를 생성. 게임 시작, 이미지 판정, 선후공 전환, 게임 종료 등을 수신할 수 있다.
2. 서버는 유저 정보, 통신 정보를 UserConnection에 저장한다.
3. 유저를 큐에 넣는다.
4. 클라이언트2가 서버에 통신을 요청하고, 저장된다.
5. 매칭이 성립된다.
6. 컨트롤러는 게임 객체를 생성하고 고유의 id를 발급한다. 이때 id는 DB에서 관리하기 위한 절대적인 id, 통신을 위해 현재 진행 중인 게임을 관리하기 위한 id 두 개가 필요하다.
7. 게임 객체가 생성되면서 하는 일
    1. 두 개의 userConnection을 parameter로 받아 저장, 선후공 결정
    2. 게임 고유의 id를 저장
    3. 게임이 생성된 절대시간을 측정함, 절대시간 + 적당한 딜레이 시간(3초?)를 게임의 시작시간으로 규정
    4. 통신 서비스로부터 메시지를 수신할 수 있는 비동기적인 eventListener를 생성
    5. 스프링 스케쥴러를 이용해 게임시작 30초 이후에 event가 발생하도록 함
    6. 클라이언트 1, 2의 식별자(uri || sessionID), 게임이 생성되었다는 메시지, 상대방의 정보, 선후공 정보, 게임 시작 시각을 담아 통신 서비스의 메소드를 호출 → 통신 서비스가 식별자를 이용해 둘에게 메시지를 전송
8. 클라이언트가 메시지를 수신하면 하는 일
    1. 게임 화면으로 전환
    2. 상대방 유저 정보와 선후공을 화면에 송출
    3. openVidu 통신 시작(아직 안 해봄)
    4. 절대시간 + 딜레이를 시작시간으로 규정, 게임 시작
9. 수비 역할의 클라이언트는 n ms마다 이미지를 서버로 전송한다. (통신을 위해 별도의 식별자를 필요로 하는지?)
10. 서버는 이미지를 수신하면 헤더에 식별자를 담아 파이썬 서버로 보낸다.
11. 파이썬은 이미지를 판정하고 받은 헤더를 그대로 담아 스프링 서버로 보낸다.
12. 스프링 서버는 헤더를 열어보고 두 클라이언트에 각각 결과를 보낸다. (uri || sessionID) (탈락이 아닌 경우)
    1. 클라이언트는 판정 결과를 화면에 송출한다.
13. 스프링 서버가 탈락 결과를 수신한 경우, 게임 객체에 결과를 보낸다.
